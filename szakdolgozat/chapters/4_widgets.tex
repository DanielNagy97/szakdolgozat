\Chapter{Interaktív grafikus elemek}

\Section{Widget-ek}

A program használata során a felhasználó különféle virtuális interaktív grafikus elemekkel léphet kapcsolatba, segítségükkel irányíthatja a programot, befolyásolhatja a prezentáció menetét. Az elemek más-más funkcióval rendelkeznek. Megjelenítés szempontjából minden grafikus elem képek segítségével jelenik meg.

\begin{itemize}
	\item \textbf{Button}: Az egyik legegyszerűbb interaktív elem, egy virtuális nyomógomb, melyet megnyomva egy meghatározott funkciót érhetünk el.
	\item \textbf{Grabbable}: A prezentáló személy a \textit{Drag and Drop} gesztus-sorozat segítségével megtudja fogni az ilyen tulajdonsággal rendelkező elemeket, majd kívánt új pozíciójába helyezheti azt.
	\item \textbf{Shiftable}: A felhasználó \textit{Shift} gesztus segítségével léphet kapcsolatba az ilyen típusú elemekkel, a képtartományon belül tologathatja azokat.
	\item \textbf{Openable}: Ezen elemek nyithatóak, zárhatóak.
	\item \textbf{Rollable}: Egy rögzített ablakon keresztül vizsgálhatunk egy hosszú kép részletét. A felhasználónak lehetősége van megváltoztatnia a megjelenítendő képrészletet a virtuális elem görgetésével.
	\item \textbf{Scale}: Két képből áll össze, segítségével értékeket állíthatunk be.
	\item \textbf{Tuner}: Virtuális "potméter". A \textit{Rotation} gesztussal léphetünk kapcsolatba vele és értékeket állíthatunk be egy meghatározott tartományon.
\end{itemize} 

\SubSection{Button}

A \textit{Button} vagy \textit{Nyomógomb} működtetése rendkívül egyszerű. Aktiválásához a felhasználónak egyszerűen csak a gomb területére kell emelnie például a kézfejét, a gomb pedig egy bizonyos idő elteltével reagál.

A gombon belüli mozgás figyelésére segítségül hívhatjuk a \textit{Hőtérkép} csoportjait. Ha egy csoport súlypontja a gombon belül helyezkedik el, majd ha megszűnik (vagyis ha a csoporthoz tartozó valódi objektum abbahagyja a mozgását), akkor a megszűnt csoport súlypontjának a koordinátáira egy figyelendő pontot helyezünk. Ha a vizsgálandó pont kilép a gomb tartományából egy előre meghatározott időn belül, akkor nem történik semmi. Ha viszont a vizsgálandó pont a gomb területén belül marad, a gomb aktiválódik. 
Vagyis ez egy valós helyzetben a következőképpen nézhet ki: A felhasználó a gomb területére irányítja a kézfejét, a kézfejének apró mozdulatai (melyek nem figyelhetőek meg a \textit{Hőtérképen} a képzaj kiküszöbölése miatt) egy vizsgálandó pont segítségével lesznek követve, amely a már ismert \textit{Optical-Flow} technikával valósul meg.

A véletlen gombnyomás, nem kívánt viselkedés elkerülése érdekében időkeretet kell megszabnunk a vizsgálandó pont a gombon belül töltött idejére. Ezen időintervallumnak viszonylag rövidnek kell lennie, hogy a felhasználói élmény ne romoljon (ne kelljen várni túl sokáig a gombnyomásra), viszont nem lehet túl rövid ahhoz, hogy egy esetleges véletlen mozdulat aktiválni tudja. A helyes időkeret megválasztása a gomb méretétől is függhet. Tapasztalati adatok szerint 0.2-0.5 másodperc közötti időkeret használata megfelelőnek tűnik.

\SubSection{Grabbable}

A megfogható tulajdonsággal rendelkező objektumokat a felhasználó a képtartományon belül szabadon áthelyezheti kedve szerint. A művelethez egy \textit{Drag and Drop} gesztust-sorozatot kell végrehajtania. A \textit{Blink} gesztus kiadásakor minden esetben számolódik egy pozíció érték, amely a kézfej helyzetét kívánja megbecsülni. Ha ezen pont az elem területére esik, akkor a pontot innentől kezdve vizsgálandó pontnak kell tekintenünk. A pont helyzetének frissítése az \textit{Optical-Flow} technikával történik. Az elem új pozíciója a ponthoz képest módosul, vagyis az elem a felhasználó kézfejét követi.
Amint elnavigálta a kívánt pozícióba az új elemet a felhasználó, eg újabb \textit{Blink} gesztussal a helyére teheti azt.

Hogy az elem véletlenül se lépjen ki a videófolyamból, korlátoznunk kell a lehetséges mozgásterét a képtartományra. Vagyis az elem szélei nem mehetnek túl a kép szélein. Ezen megszorítás a többi elemre is vonatkozik.

\SubSection{Shiftable}

A tologatható elemekkel \textit{Shift} gesztus segítségével léphetünk kapcsolatba. Az irányukba történő mozgásra megeggyező irányú mozgással reagálnak. Működésére olyan hatás jellemző, mintha az elemet tologatnánk.

\SubSection{Openable}

Ezen virtuális elemek megjelenés szempontjából hasonlítanak egy pargamen tekercshez, belső tartalmuk kezdetben rejtett, azonban a felhasználónak lehetősége van kinyitni, megmutatva a belső tartalmát, majd becsukni az adott elemet.

A \textit{Tologatható elemekhez} hasonlóan, \textit{Shift} gesztussal léphetünk kapcsolatba az ilyen tulajdonságokkal ellátott elemekkel, viszont az ilyen típusú elemek mozgása egy bizonyos tengelyre korlátozódik, kezdőpozícióját megtartja és a megjelenítendő képrészlet nagysága változik csupán. Az elemhez definiálnunk kell a \textit{header} szekció méretét, ami az elem minimum méretét fogja megadni. Mivel az elem viselkedését a vektormező adataiból számoljuk, ezért a \textit{header} mérete nem lehet kisebb a rács sűrűségéből számított lépésköznél, hiszen ilyenkor bizonyos esetekben az elem becsukott állapotban egyetlen kontrollpontot sem fedne le, így a felhasználó nem tudna interakcióba lépni vele.
Az elem tényleges mérete pedig a teljesen kinyitott állapototára vonatkozik.

\SubSection{Rollable}

A \textit{Rollable} virtuális elemek rögzített pozíciójú, fix méretű widgetek.

Működés szempontjából hasonlítanak egy diavetítőre, hiszen a hozzá tartozó nagy méretű képet egy ablakon keresztül szemlélhetjük, a megjelenítendő képrészletet pedig a felhasználó kedve szerint változtathatja, vagyis úgy tűnik, mintha görgetné az adott ablakon található tartalmat.

Az ilyen típusú widgeteket is a \textit{Shift} gesztus segítségével vezérelhetjük. A gesztus végrehajtása során kiszámolódik a megjelenítendő képrészlet \textit{kezdőpozíciója}, ami alapján, az \textit{ablak méretét} figyelembe véve meghatározható az eredeti képből kivágandó képrészlet.
A helyes működés érdekében a képrészlet kezdőpozíciójának értékét korlátoznunk kell. Az értéke nem lehet nullánál kisebb, illetve nem lehet nagyobb a hozzá tartozó kép magasságának és az ablakméret magasságának különbségénél ($y$ tengelyen görgethető \textit{Rollable} widget esetében).
\begin{align*}
	0 \leq \textit{képrészlet kezdőpozíciója} \leq (\textit{képmagasság} - \textit{ablakmagasság})
\end{align*}

Így elkerülhetők a hibás vágások, illetve megakadályozható a kép kicsúszása az ablakból.
A megjelenítendő kép

\SubSection{Scale}

Néhány gondolat a \textit{Csúszkákról}.

\SubSection{Tuner}

A \textit{Tuner} widget-et működése és megjelenése szempontjából egy potméter gombnak képzelhetjük el. Segítségével a felhasználó különböző értékeket állíthat be.
Az ilyen típisú widgeteket a \textit{Rotation} gesztus segítségével érhetjük el. Ha a \textit{Rotation} becsült forgási középpontja az adott elem belsejébe esik, az aktiválódik és a gesztus feldolgozása során további információkat figyelembe véve változik meg az állapota.

A felhasználó definiálhatja, hogy az egyes ilyen típusú widget-ek értékei milyen tartományon szerepelhetnek, vagyis meg kell határoznia a legkisebb és legnagyobb értéket, amelyet a widget felvehet. Az értékek számítása a forgási szög függvényében történik. A widget élete során kapott elfordulás szögei szummázódnak és a widget értéke ezen szummázott szög alapján számolódik. A szummázott összegre vonatkozik egy olyan megszorítás, hogy értéke, fokokban nézve, nem lehet 0$^{\circ}$ alatt és 360$^{\circ}$ fölött. Egy tomptó értéket is be kell vezetnünk, amellyel a szummázás előtt az eredeti szög értékét csökkentjük. Ez az érték tapasztalata alapokon 10, vagyis a tényleges becsült forgási szög tizedét vesszük csak figyelembe a finomabb működés érdekében.
Megjelenés szempontjából a \textit{Tuner} widget valóban elfordul. A hatás eléréséhez minden iterációban a widget súlypontját és a szummázott szöget felhasználva affin transzormációval elforgatjuk a widget eredeti képét.
